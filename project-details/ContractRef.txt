Generated Contract & Library Reference
Generated by dv-test.js on 2025-09-03T03:24:27.663Z
Network: sepolia
Deployer: 0x8842fcE43C34ca29b2B4182ca3A5D817c211Cb49

Contract: CeoManager
Source: contracts/CeoManager.sol
Address: N/A
Code:
//CeoManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./libraries/Errors.sol";
import "./libraries/EventLib.sol";

abstract contract CeoManager {
    uint256 public constant ELECTED_CEO_ACTIVATION_DELAY = 360 hours;

    address public currentCeo;
    address public electedCeo;
    uint256 public electedCeoTimestamp;

    enum CeoStatus { None, Nominated, Elected, Active }
    mapping(address => CeoStatus) public ceoStatus;

    modifier onlyCEO() {
        if (msg.sender != currentCeo) revert Errors.OnlyCeo();
        _;
    }

    function _setCeo(address newCeo) internal {
        address previous = currentCeo;
        if (previous != address(0)) {
            ceoStatus[previous] = CeoStatus.None;
        }
        currentCeo = newCeo;
        if (newCeo != address(0)) {
            ceoStatus[newCeo] = CeoStatus.Active;
        }
        if (previous != newCeo) {
            emit EventLib.CeoChanged(previous, newCeo);
        }
    }
}

Contract: ExchangeManager
Source: contracts/ExchangeManager.sol
Address: N/A
Code:
//ExchangeManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./interfaces/AggregatorV3Interface.sol";
import "./InvUsdToken.sol";
import "./CeoManager.sol";
import "./interfaces/IFundingManager.sol";
import "./libraries/Errors.sol";
import "./libraries/PriceLib.sol";
import "./libraries/EventLib.sol";
import "./libraries/FundingLib.sol";
import "./libraries/ProposalLib.sol";

/// @title ExchangeManager
/// @notice Handles INV-USD exchange limits and conversion logic.
abstract contract ExchangeManager is CeoManager, ReentrancyGuard {
    InvUsdToken public invUsdToken;
    AggregatorV3Interface internal priceFeed;
    IFundingManager public fundingManager;

    // --- Price Guard ---
    int public lastPrice;
    uint256 public constant MAX_PRICE_DEVIATION_BPS = 1000; // 10%

    // --- State Variables for Exchange Limits ---
    mapping(uint256 => uint256) internal dailyExchangeLimit;
    mapping(uint256 => uint256) internal dailyExchangedAmount;
    mapping(uint256 => uint256) internal lastExchangeDay;
    mapping(uint256 => uint256) internal remainingToExchange;

    /// @notice Fetch exchange parameters for a funding request in a single call.
    /// @param requestId Identifier of the funding request.
    /// @return limit Daily exchange cap for the request.
    /// @return exchanged Amount of INV-USD exchanged today.
    /// @return lastDay Last day when an exchange occurred.
    /// @return remaining INV-USD still available for exchange.
    function getExchangeState(uint256 requestId)
        external
        view
        returns (
            uint256 limit,
            uint256 exchanged,
            uint256 lastDay,
            uint256 remaining
        )
    {
        limit = dailyExchangeLimit[requestId];
        exchanged = dailyExchangedAmount[requestId];
        lastDay = lastExchangeDay[requestId];
        remaining = remainingToExchange[requestId];
    }

    /// @dev Hooks that allow the composing contract to expose core DAO state (vesting removed)
    function _totalSupply() internal view virtual returns (uint256);
    function _getTotalTokensLocked() internal view virtual returns (uint256);

    /// @dev Required mint hook implemented by the composing contract
    function _daoMint(address to, uint256 amount) internal virtual;

    /// @notice Update the Chainlink price feed used for INV/USD conversions.
    /// @param newFeed Address of the new price feed contract.
    function setPriceFeed(address newFeed) external onlyCEO {
        if (newFeed == address(0)) revert Errors.InvalidFeedAddress();
        priceFeed = AggregatorV3Interface(newFeed);
        lastPrice = PriceLib.getLatestPrice(priceFeed);
        emit EventLib.PriceFeedUpdated(newFeed, lastPrice);
    }

    // Note: legacy unswapped-accounting functions removed.

    /// @notice Limit how much INV-USD can be converted back to INV each day for a request.
    /// @param requestId The funding request to configure.
    /// @param limitPercent Percentage of the total amount that may be exchanged per day.
    function setDailyExchangeLimit(uint256 requestId, uint256 limitPercent)
        external
        onlyCEO
    {
        if (limitPercent == 0 || limitPercent > 100) revert Errors.InvalidLimitPercent();
        if (fundingManager.fundingStatus(requestId) != uint8(ProposalLib.ProposalStatus.Executed)) {
            revert Errors.FundingRequestNotExecuted();
        }
        uint256 total = fundingManager.fundingAmount(requestId) * 1e12;
        uint256 limit = (total * limitPercent) / 100;
        dailyExchangeLimit[requestId] = limit;
        emit EventLib.DailyLimitSet(requestId, limit);
    }

    /// @notice Exchange previously minted INV-USD back into INV governance tokens.
    /// @param requestId The funding request being converted.
    /// @param invUsdAmount Amount of INV-USD to exchange.
    function exchangeInvUsdForInv(uint256 requestId, uint256 invUsdAmount) external nonReentrant {
        if (fundingManager.fundingStatus(requestId) != uint8(ProposalLib.ProposalStatus.Executed)) {
            revert Errors.FundingRequestNotExecuted();
        }
        if (msg.sender != fundingManager.proposerOf(requestId)) revert Errors.OnlyProposer();
        if (dailyExchangeLimit[requestId] == 0) revert Errors.ExchangeDisabled();
        if (remainingToExchange[requestId] < invUsdAmount) revert Errors.AmountExceedsRemaining();

        uint256 today = block.timestamp / 1 days;
        if (lastExchangeDay[requestId] != today) {
            lastExchangeDay[requestId] = today;
            dailyExchangedAmount[requestId] = 0;
        }
        if (dailyExchangedAmount[requestId] + invUsdAmount > dailyExchangeLimit[requestId]) {
            revert Errors.ExceedsDailyLimit();
        }

        int currentPrice = PriceLib.getLatestPrice(priceFeed);
        if (lastPrice != 0) {
            uint256 diff = currentPrice > lastPrice
                ? uint256(currentPrice - lastPrice)
                : uint256(lastPrice - currentPrice);
            if (diff * 10000 > uint256(lastPrice) * MAX_PRICE_DEVIATION_BPS) {
                revert Errors.PriceOutOfBounds();
            }
        }
        invUsdToken.burnFrom(msg.sender, invUsdAmount);
        uint256 invAmount = (invUsdAmount * 1e18) / uint256(currentPrice);
        _daoMint(msg.sender, invAmount);
        dailyExchangedAmount[requestId] += invUsdAmount;
        remainingToExchange[requestId] -= invUsdAmount;
        lastPrice = currentPrice;
        emit EventLib.Exchanged(msg.sender, invUsdAmount, invAmount);
    }
}

Contract: FundingManager
Source: contracts/FundingManager.sol
Address: 0xf5B3D56E269684c81137e8d54415f34Bc5abb91a
Code:
//FundingManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./libraries/FundingLib.sol";

abstract contract FundingManager {
    using FundingLib for FundingLib.State;
    FundingLib.State internal _fundingState;

    function nextFundingRequestId() external view returns (uint256) {
        return _fundingState.nextFundingRequestId;
    }

    function fundingRequests(uint256 id)
        external
        view
        returns (FundingLib.FundingRequest memory)
    {
        return _fundingState.fundingRequests[id];
    }
}

Contract: FundingManagerContract
Source: contracts/FundingManagerContract.sol
Address: N/A
Code:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./libraries/ProposalLib.sol";
import "./libraries/EventLib.sol";
import "./libraries/Errors.sol";
import "./libraries/FundingLib.sol";
import "./WhitelistManager.sol";
import "./interfaces/IInvtronDao.sol";

/**
 * @title FundingManagerContract
 * @notice Standalone manager for funding requests, connected to INVTRON_DAO similar to WhitelistManager.
 * @dev Holds funding state and voting-specific storage; calls back into DAO for locks, pricing and mints.
 */
contract FundingManagerContract {
    using FundingLib for FundingLib.State;

    // --- DAO wiring ---
    address public dao;

    // --- Config ---
    uint256 public constant VOTING_PERIOD = 72 hours;
    uint256 public constant ENDORSER_VOTES_FOR_FUNDING_PASS = 3; // adjust on mainnet if needed

    // --- Core State ---
    FundingLib.State internal _fundingState;

    // --- Vote tracking state (funding-specific) ---
    mapping(uint256 => mapping(address => bool)) public fundingEndorsersVoted;
    mapping(uint256 => mapping(address => bool)) public fundingUsersVoted;
    mapping(uint256 => mapping(address => bool)) public fundingUserVoteChoice;
    mapping(uint256 => mapping(address => uint256)) public votingPowerAtVote;     // USD(6) base portion
    mapping(uint256 => mapping(address => uint256)) public delegateePowerAtVote;  // USD(6) delegated portion
    mapping(uint256 => mapping(address => address)) public delegateAtVote;
    mapping(uint256 => mapping(address => bool)) public rewardClaimed;

    // --- One-time DAO setter ---
    function setDao(address _dao) external {
        if (dao != address(0)) revert Errors.DaoAlreadySet();
        if (_dao == address(0)) revert Errors.DaoAddressZero();
        dao = _dao;
    }

    // --- Internal guards ---
    function _onlyCeo() internal view {
        IInvtronDao d = IInvtronDao(dao);
        if (!d.hasRole(d.CEO_ROLE(), msg.sender)) revert Errors.OnlyCeo();
    }

    function _onlyEndorser() internal view {
        IInvtronDao d = IInvtronDao(dao);
        if (!d.hasRole(d.ENDORSER_ROLE(), msg.sender)) revert Errors.OnlyEndorser();
    }

    function _onlyWhitelisted(address user) internal view {
        address wl = IInvtronDao(dao).whitelistManager();
        if (!WhitelistManager(wl).isWhitelisted(user)) revert Errors.NotWhitelisted();
    }

    // --- Views ---
    function nextFundingRequestId() external view returns (uint256) {
        return _fundingState.nextFundingRequestId;
    }

    function fundingRequests(uint256 id)
        external
        view
        returns (FundingLib.FundingRequest memory)
    {
        return _fundingState.fundingRequests[id];
    }

    function fundingStatus(uint256 id) external view returns (uint8) {
        return uint8(_fundingState.fundingRequests[id].status);
    }

    function fundingAmount(uint256 id) external view returns (uint256) {
        return _fundingState.fundingRequests[id].amount;
    }

    function proposerOf(uint256 id) external view returns (address) {
        return _fundingState.fundingRequests[id].proposer;
    }

    // --- Funding lifecycle ---

    /// @notice Propose a new funding request with caps expressed in USDT(6d).
    function createFundingRequest(FundingLib.FundingDetails calldata details) external {
        _onlyWhitelisted(msg.sender);
        if (
            details.softCapAmount == 0 ||
            details.hardCapAmount == 0 ||
            details.softCapAmount > details.hardCapAmount
        ) {
            revert Errors.InvalidFundingCaps();
        }
        if (details.valuation == 0) revert Errors.InvalidValuation();

        // Collect funding request fee in INV (uses DAO to pull allowance and transfer to treasury)
        int p = IInvtronDao(dao).getLatestUsdPrice();
        if (p <= 0) revert Errors.OraclePriceInvalid();
        uint256 price = uint256(p);
        uint256 feeInInv = (100 * 1e18 * 1e18) / uint256(price); // FUNDING_REQUEST_FEE = $100
        // Caller must approve DAO; manager instructs DAO to collect
        // Use a dedicated fee-collector hook to avoid exposing ERC20 internals; implemented in DAO
        IInvtronDao(dao).collectInvFee(msg.sender, feeInInv);

        FundingLib.createFundingRequest(
            _fundingState,
            msg.sender,
            details,
            VOTING_PERIOD
        );
    }

    // fee collection helper removed (using typed interface)

    /// @notice Endorsers vote on a funding request before it is opened to all users.
    function voteOnFundingByEndorser(uint256 id) external {
        _onlyEndorser();
        FundingLib.FundingRequest storage req = _fundingState.fundingRequests[id];
        if (req.status != ProposalLib.ProposalStatus.Pending) revert Errors.FundingProposalNotPending();
        if (block.timestamp >= req.deadline) {
            req.status = ProposalLib.ProposalStatus.Defeated;
            emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Defeated));
            revert Errors.FundingVotingEnded();
        }
        if (fundingEndorsersVoted[id][msg.sender]) revert Errors.FundingEndorserAlreadyVoted();
        fundingEndorsersVoted[id][msg.sender] = true;
        req.endorserVotes++;
        if (req.endorserVotes >= ENDORSER_VOTES_FOR_FUNDING_PASS) {
            req.status = ProposalLib.ProposalStatus.Active;
            req.deadline = block.timestamp + VOTING_PERIOD;
            emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Active));
        }
    }

    /// @notice Expire a pending funding request if deadline passed without enough endorser votes.
    function expireFundingRequest(uint256 id) external {
        FundingLib.FundingRequest storage req = _fundingState.fundingRequests[id];
        if (req.status != ProposalLib.ProposalStatus.Pending) revert Errors.FundingProposalNotPending();
        if (block.timestamp < req.deadline) revert Errors.FundingVotingActive();
        req.status = ProposalLib.ProposalStatus.Defeated;
        emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Defeated));
    }

    /// @notice Users vote on a funding request using their delegated voting power.
    function voteOnFundingByUser(uint256 id, bool inFavor, address tokenHolder) external {
        FundingLib.FundingRequest storage req = _fundingState.fundingRequests[id];
        if (req.status != ProposalLib.ProposalStatus.Active) revert Errors.FundingProposalNotActiveUser();
        if (block.timestamp >= req.deadline) revert Errors.FundingVotingEnded();

        // Prepare delegated vote and snapshot lock inside DAO
        address voter = IInvtronDao(dao).prepareFundingVote(msg.sender, tokenHolder);
        if (voter == address(0)) revert Errors.InvalidTokenHolder();

        if (voter == req.proposer) revert Errors.SelfVoting();

        if (fundingUsersVoted[id][voter]) revert Errors.FundingUserAlreadyVoted();

        // --- Price validation & normalization ---
        int p = IInvtronDao(dao).getLatestUsdPrice();
        if (p <= 0) revert Errors.OraclePriceInvalid();
        uint256 price = uint256(p);
        // Original unclamped powers (USD6), derived from delegated votes model:
        uint256 senderPower = _getVotingValueByVotes(msg.sender, int(price), req.amount);
        uint256 delegatedPower = 0;
        if (voter != msg.sender) {
            delegatedPower = _getVotingValueByVotes(voter, int(price), req.amount);
        }
        uint256 rawPower = senderPower + delegatedPower;
        uint256 power = rawPower;

        // -------- Cross-type headroom clamp (prevents "free votes") --------
        // Headroom tokens available for *any* new lock right now:
        uint256 headroomSender = IInvtronDao(dao).freeHeadroomTokens(msg.sender);
        uint256 headroomVoter  = voter != msg.sender ? IInvtronDao(dao).freeHeadroomTokens(voter) : 0;
        // Maximum USD capacity implied by headroom (must be covered by actual lock later):
        //   lockTokens = usd6 * 200 * 1e30 / price  =>  usd6 = lockTokens * price / (200 * 1e30)
        uint256 maxUsdBySenderFree = (headroomSender * price) / (200 * 1e30);
        uint256 maxUsdByVoterFree  = voter != msg.sender ? (headroomVoter  * price) / (200 * 1e30) : 0;

        // Clamp each leg independently by the USD capacity implied by its free tokens.
        if (senderPower > maxUsdBySenderFree) senderPower = maxUsdBySenderFree;
        if (delegatedPower > maxUsdByVoterFree) delegatedPower = maxUsdByVoterFree;
        power = senderPower + delegatedPower;
        if (power == 0) {
            if (rawPower > 0) revert Errors.TokensLocked();
            revert Errors.NoVotingPower();
        }
        // Clamp applied vote so raised never exceeds hardcap and never drops below zero
        uint256 currentRaised = _currentRaisedClamped(req);
        uint256 applied;
        if (inFavor) {
            uint256 room = req.details.hardCapAmount > currentRaised
                ? (req.details.hardCapAmount - currentRaised)
                : 0;
            applied = power > room ? room : power;
            if (applied == 0) revert Errors.NoVotingPower(); // prevent zero-effect "for" votes

            req.userVotesFor += applied;
        } else {
            applied = power > currentRaised ? currentRaised : power;
            if (applied == 0) revert Errors.NoVotingPower(); // prevent zero-effect "against" votes

            req.userVotesAgainst += applied;
        }

        fundingUsersVoted[id][voter] = true;
        fundingUserVoteChoice[id][voter] = inFavor;

        // Scale stored powers proportionally to applied vote for reward calculations
        uint256 appliedSender = senderPower;
        uint256 appliedDelegated = delegatedPower;
        if (power > 0 && applied < power) {
            appliedSender = (senderPower * applied) / power;
            appliedDelegated = applied - appliedSender;
        }
        // Lock tokens for the sender, proportional to their contribution.
        if (appliedSender > 0) {
            // Lock intention & units:
            // - Voting power here is USD(6).
            // - Convert USD(6) -> tokens (18d): tokens = usd6 * 1e30 / price (price has 18d).
            // - Apply LOCK_FACTOR = 200 so that $1 at $1/INV locks 200 INV.
            //   Example: appliedSender = $1 => 1e6 * 200 * 1e30 / 1e18 = 200e18 (200 tokens).

            uint256 senderLockTokens = (appliedSender * 200 * 1e30) / price;
            IInvtronDao(dao).lockTokensForFunding(msg.sender, senderLockTokens);
        }
        // If a delegate was used, lock their tokens as well, proportional to their contribution.
        if (voter != msg.sender && appliedDelegated > 0) {
            // Same formula as above, applied to the delegated portion
            uint256 delegatedLockTokens = (appliedDelegated * 200 * 1e30) / price;
            IInvtronDao(dao).lockTokensForFunding(voter, delegatedLockTokens);
        }
        if (voter == msg.sender) {
            votingPowerAtVote[id][voter] = appliedSender;
        } else {
            votingPowerAtVote[id][voter] = appliedDelegated;
            delegateePowerAtVote[id][voter] = appliedSender;
        }
        // Persist delegate-at-vote from DAO mapping
        delegateAtVote[id][voter] = IInvtronDao(dao).getDelegate(voter);

        emit EventLib.Voted(id, voter, inFavor, applied);
    }

    /// @notice Finalize a funding request that failed to reach majority support.
    function finalizeFundingRequest(uint256 id) external {
        FundingLib.FundingRequest storage req = _fundingState.fundingRequests[id];
        if (req.status != ProposalLib.ProposalStatus.Active) revert Errors.FundingProposalNotActive();
        if (block.timestamp < req.deadline) revert Errors.FundingVotingActive();
        if (req.userVotesFor > req.userVotesAgainst) revert Errors.FundingProposalPassed();
        req.status = ProposalLib.ProposalStatus.Defeated;
        emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Defeated));
    }

    /// @notice CEO approval required before a passed funding request can mint tokens.
    function releaseFundingRequest(uint256 id) external {
        _onlyCeo();
        FundingLib.releaseFundingRequest(_fundingState, id);
    }

    /// @notice Execute a passed funding request to mint INV-USD and seed exchange state in DAO.
    function mintTokensForFundingRequest(uint256 id) external {
        FundingLib.FundingRequest storage req = _fundingState.fundingRequests[id];
        if (_currentRaisedClamped(req) == 0) revert Errors.FundingProposalFailed();
        if (req.status != ProposalLib.ProposalStatus.Active) revert Errors.FundingProposalNotActiveExecution();
        if (block.timestamp < req.deadline) revert Errors.FundingVotingActiveExecution();
        if (req.userVotesFor <= req.userVotesAgainst) revert Errors.FundingProposalFailed();
        if (!req.ceoApproved) revert Errors.FundingRequestNotApproved();

        // Mark executed
        req.status = ProposalLib.ProposalStatus.Executed;
        uint256 mintAmount = req.amount * 1e12; // convert USD(6) to token(18)

        // Mint INV-USD via DAO (owner of token) and seed exchange remaining
        IInvtronDao(dao).mintInvUsdByManager(req.proposer, mintAmount);
        IInvtronDao(dao).seedExchangeRemaining(id, mintAmount);

        emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Executed));
    }

    // --- Rewards ---
    /// @notice View expected reward for a voter after finalization.
    function getVotingReward(uint256 fundingRequestId, address voter)
        external
        view
        returns (uint256 rewardInvWei)
    {
        FundingLib.FundingRequest storage req = _fundingState.fundingRequests[fundingRequestId];
        if (!(req.status == ProposalLib.ProposalStatus.Executed || req.status == ProposalLib.ProposalStatus.Defeated)) {
            return 0;
        }
        if (!fundingUsersVoted[fundingRequestId][voter]) return 0;
        bool votedFor = fundingUserVoteChoice[fundingRequestId][voter];
        bool correct = (req.status == ProposalLib.ProposalStatus.Executed && votedFor) ||
            (req.status == ProposalLib.ProposalStatus.Defeated && !votedFor);
        if (!correct) return 0;

        uint256 price = uint256(IInvtronDao(dao).getLatestUsdPrice());
        if (price == 0) return 0;
        (address delegatee, uint256 baseInv, uint256 delegateInv) = _payoutParts(fundingRequestId, voter, price);
        if (delegatee != address(0)) {
            rewardInvWei = (baseInv * 90) / 100;
        } else {
            rewardInvWei = baseInv + delegateInv;
        }
    }

    /// @notice Claim voting rewards for a funding proposal.
    function claimReward(uint256 fundingRequestId) external {
        if (rewardClaimed[fundingRequestId][msg.sender]) revert Errors.RewardAlreadyClaimed();
        FundingLib.FundingRequest storage req = _fundingState.fundingRequests[fundingRequestId];
        if (!(req.status == ProposalLib.ProposalStatus.Executed || req.status == ProposalLib.ProposalStatus.Defeated)) {
            revert Errors.ProposalNotFinalized();
        }
        if (!fundingUsersVoted[fundingRequestId][msg.sender]) revert Errors.AddressDidNotVote();
        bool votedFor = fundingUserVoteChoice[fundingRequestId][msg.sender];
        bool correct = (req.status == ProposalLib.ProposalStatus.Executed && votedFor) ||
            (req.status == ProposalLib.ProposalStatus.Defeated && !votedFor);
        if (!correct) revert Errors.VoteMismatch();

        uint256 price = uint256(IInvtronDao(dao).getLatestUsdPrice());
        if (price == 0) revert Errors.OraclePriceInvalid();
        (address delegatee, uint256 baseInv, uint256 delegateInv) = _payoutParts(fundingRequestId, msg.sender, price);
        rewardClaimed[fundingRequestId][msg.sender] = true;
        if (delegatee != address(0)) {
            uint256 delegatorShare = (baseInv * 90) / 100;
            uint256 delegateeShare = (baseInv + delegateInv) - delegatorShare;
            IInvtronDao(dao).mintGovByManager(msg.sender, delegatorShare);
            IInvtronDao(dao).mintGovByManager(delegatee, delegateeShare);
            emit EventLib.RewardClaimed(msg.sender, delegatorShare);
        } else {
            uint256 totalReward = baseInv + delegateInv;
            IInvtronDao(dao).mintGovByManager(msg.sender, totalReward);
            emit EventLib.RewardClaimed(msg.sender, totalReward);
        }
    }

    // --- Internals ---
    /// @dev Convert a USD(6) voting value into INV(18) at 22% reward.
    ///      tokensWei = usd6 * 22% * 1e30 / price(18)  ==  usd6 * 22 * 1e28 / price
    function _toInv(uint256 usd6, uint256 price) internal pure returns (uint256) {
        // exact integer math for wei:
        // return (usd6 * 22 * 1e30) / (100 * price);
        return (usd6 * 22 * 1e28) / price;
    }

    function _getVotingValueByVotes(address who, int price, uint256 requestAmount)
        internal
        view
        returns (uint256 value)
    {
        // --- Constants for the model (using basis points for precision) ---
        uint256 BASE_RATE_BPS = 5; // 0.05%
        uint256 MAX_RATE_BPS = 50; // 0.5%
        uint256 MATURATION_PERIOD_SECONDS = 12 * 30 days; // 12 months

        // 1. Get user's INV balance and its USD value
        uint256 vp = IInvtronDao(dao).getPastVotes(who, block.number - 1);
        uint256 invValueUsd = (vp * uint256(price)) / 1e30; // USD(6)

        // 2. Get the user's holding duration from the DAO
        uint256 age = IInvtronDao(dao).balanceAge(who);
        uint256 holdingDuration = block.timestamp > age ? block.timestamp - age : 0;

        // 3. Calculate the effective rate in basis points
        uint256 effectiveRateBps;
        if (holdingDuration >= MATURATION_PERIOD_SECONDS) {
            effectiveRateBps = MAX_RATE_BPS;
        } else {
            uint256 rateIncreaseBps = MAX_RATE_BPS - BASE_RATE_BPS;
            uint256 bonusBps = (rateIncreaseBps * holdingDuration) / MATURATION_PERIOD_SECONDS;
            effectiveRateBps = BASE_RATE_BPS + bonusBps;
        }

        // 4. Calculate the time-weighted voting value
        value = (invValueUsd * effectiveRateBps) / 10000;

        // 5. Apply the existing 10% cap relative to the request amount
        uint256 maxValue = requestAmount / 10;
        if (value > maxValue) {
            value = maxValue;
        }
    }

    function _currentRaisedClamped(FundingLib.FundingRequest storage req)
        internal
        view
        returns (uint256 raised)
    {
        if (req.userVotesFor > req.userVotesAgainst) {
            raised = req.userVotesFor - req.userVotesAgainst;
        }
        uint256 cap = req.details.hardCapAmount;
        if (raised > cap) raised = cap;
    }

    function _payoutParts(uint256 fundingRequestId, address voter, uint256 price)
        internal
        view
        returns (address delegatee, uint256 baseInv, uint256 delegateInv)
    {
        FundingLib.FundingRequest storage req = _fundingState.fundingRequests[fundingRequestId];
        bool votedFor = fundingUserVoteChoice[fundingRequestId][voter];
        bool correct = (req.status == ProposalLib.ProposalStatus.Executed && votedFor) ||
            (req.status == ProposalLib.ProposalStatus.Defeated && !votedFor);
        if (!correct) return (address(0), 0, 0);
        delegatee = delegateAtVote[fundingRequestId][voter];
        baseInv = _toInv(votingPowerAtVote[fundingRequestId][voter], price);
        delegateInv = _toInv(delegateePowerAtVote[fundingRequestId][voter], price);
    }
}

Contract: INVTRON_DAO
Source: contracts/INVTRON_DAO.sol
Address: N/A
Code:
//Main Contract: INVTRON_DAO.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "./interfaces/AggregatorV3Interface.sol";
import "./libraries/VotingLib.sol";
import "./libraries/Errors.sol";
import "./libraries/PriceLib.sol";
import "./libraries/EndorserLib.sol";
import "./libraries/DelegateLib.sol";
import "./libraries/WhitelistLib.sol";
import "./libraries/TokenHolderLib.sol";
import "./libraries/EventLib.sol";
import "./libraries/ProposalLib.sol";
import "./interfaces/IFundingManager.sol";
import "./InvUsdToken.sol";
import "./WhitelistManager.sol";
import "./CeoManager.sol";
import "./ExchangeManager.sol";

/// @dev Minimal live-votes delegation (no checkpoints, no past-block reads).
/// - Voting power mirrors current balances of delegatees.
/// - Exposes ERC20Votes-like names: delegates(), getVotes(), delegate().
enum VoteType { Ceo, Funding }

abstract contract __MinimalVotes {
    mapping(address => address) internal __delegates;     // delegator => delegatee (0 => self)
    mapping(address => uint256) internal __votingPower;   // current power per delegatee

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);

    function delegates(address account) public view returns (address) {
        return __delegates[account]; // no default self-delegation
    }

    function getVotes(address account) public view returns (uint256) {
        return __votingPower[account];
    }

    function _delegate(address delegator, address to) internal {
        address fromDel = __delegates[delegator];
        address toDel = to; // allow clearing to zero
        if (fromDel == toDel) return;
        __delegates[delegator] = toDel;
        emit DelegateChanged(delegator, fromDel, toDel);

        uint256 bal = _balanceOfForVotes(delegator);
        if (fromDel != address(0)) {
            uint256 prevFrom = __votingPower[fromDel];
            __votingPower[fromDel] = prevFrom - bal;
            emit DelegateVotesChanged(fromDel, prevFrom, prevFrom - bal);
        }
        if (toDel != address(0)) {
            uint256 prevTo = __votingPower[toDel];
            __votingPower[toDel] = prevTo + bal;
            emit DelegateVotesChanged(toDel, prevTo, prevTo + bal);
        }
    }

    function delegate(address to) public virtual {
        _delegate(msg.sender, to);
    }

    /// @dev Must be implemented by the token to expose balances for votes accounting.
    function _balanceOfForVotes(address account) internal view virtual returns (uint256);

    /// @dev Call this after any token balance change affecting `owner`.
    function _afterTokenBalanceChange(address owner, uint256 oldBal, uint256 newBal) internal {
        if (newBal == oldBal) return;
        address del = __delegates[owner];
        if (del == address(0)) return;
        if (newBal > oldBal) {
            __votingPower[del] += newBal - oldBal;
        } else {
            __votingPower[del] -= oldBal - newBal;
        }
    }
}
/**
 * @title INVTRON_DAO
 * @notice Core governance contract powering the Invtron ecosystem.
 * @dev Manages tokenized voting, funding requests and role based permissions.
 * The DAO issues INV governance tokens and an internal INV-USD voucher used
 * during funding rounds. Most state changing actions are gated by either the
 * CEO or a vote of the community.
 */
contract INVTRON_DAO is ERC20, EIP712, ExchangeManager, __MinimalVotes {

    // -------- Amount-aware helpers (same-type clamping) --------
    /// @notice Tokens not locked for CEO voting, for this holder.
    function freeTokensForCeo(address user) public view returns (uint256) {
        uint256 bal = balanceOf(user);
        // Treat expired locks as zero to avoid post-expiry undercount on first re-vote.
        uint256 req = (block.timestamp < tokenUnlockTimeForCeoVote[user])
            ? lockedBalanceForCeoVote[user]
            : 0;
        return bal > req ? bal - req : 0;
    }

    /// @notice Cross-type headroom: additional tokens that can still be locked now.
    /// @dev Treats expired locks as zero for both types; prevents "free votes" when sum==balance.
    function freeHeadroomTokens(address user) public view returns (uint256) {
        uint256 bal = balanceOf(user);
        uint256 ceoReq = (block.timestamp < tokenUnlockTimeForCeoVote[user])
            ? lockedBalanceForCeoVote[user]
            : 0;
        uint256 fundReq = (block.timestamp < tokenUnlockTimeForFundingVote[user])
            ? lockedBalanceForFundingVote[user]
            : 0;
        uint256 used = ceoReq + fundReq;
        if (bal <= used) return 0;
        return bal - used;
    }

    /// @notice Tokens not locked for Funding voting, for this holder.
    function freeTokensForFunding(address user) public view returns (uint256) {
        uint256 bal = balanceOf(user);
        // Treat expired locks as zero to avoid post-expiry undercount on first re-vote.
        uint256 req = (block.timestamp < tokenUnlockTimeForFundingVote[user])
            ? lockedBalanceForFundingVote[user]
            : 0;
        return bal > req ? bal - req : 0;
    }


    // --- Roles ---
    mapping(address => bool) private isEndorser;

    WhitelistManager public whitelistManager;

    // --- External Contracts & Feeds ---
    address public treasuryOwner;

    // --- Constants for Fees & Thresholds ---
    uint256 public constant CEO_APPLICATION_FEE = 100 * 1e18; // $100
    uint256 public constant ENDORSER_APPLICATION_FEE = 50 * 1e18; // $50
    uint256 public constant FUNDING_REQUEST_FEE = 100 * 1e18; // $100
    uint256 public constant CEO_REQUIRED_BALANCE_USD = 25000 * 1e18; // $25,000
    uint256 public constant ENDORSER_REQUIRED_BALANCE_USD = 10000 * 1e18; // $10,000
    uint256 public constant ENDORSER_VOTES_FOR_CEO_PASS = 3; // go back to 26 on mainnet
    uint256 public constant ENDORSER_VOTES_FOR_FUNDING_PASS = 3; // go back to 26 on mainnet
    uint256 public constant VOTING_PERIOD = 72 hours;
    uint256 public constant TOKEN_LOCK_DURATION = 73 hours;
    bytes32 public constant DELEGATE_VP_TYPEHASH =
        keccak256("DelegateVP(address delegatee,uint256 nonce,uint256 deadline)");

    // Same typehash OZ uses for ERC20Votes delegation
    bytes32 private constant DELEGATION_TYPEHASH =
        keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");

    mapping(address => uint256) private _nonces;

    // --- State Variables for Proposal Storage ---
    uint256 public nextCeoApplicationId;
    mapping(uint256 => CeoApplication) public ceoApplications;

    // --- State Variables for Vote Tracking (Externalized from Structs) ---
    mapping(uint256 => mapping(address => bool)) public ceoEndorsersVoted;
    mapping(uint256 => mapping(address => bool)) public ceoUsersVoted;
    // Funding vote state moved to FundingManagerContract

    // Track active applications per address to prevent duplicates
    mapping(address => uint256) public activeCeoApplication;

    // --- Dynamic Endorser Leaderboard ---
    uint256 public constant MAX_ACTIVE_ENDORSERS = 50;

    mapping(address => EndorserLib.EndorserCandidate) public endorserCandidates;
    mapping(address => address) public endorserVotes; // voter => candidate
    // Independent support weights for endorsers, separate from delegation
    mapping(address => uint256) public endorserSupport;
    // Track last recorded voter weight to adjust support when changing votes
    mapping(address => uint256) public endorserVoterWeight;
    address[] private _activeEndorserList;
    address public lowestActiveEndorser;

    // --- State Variables for Rate-Limiting & Token-Locking ---
    mapping(address => uint256) public recentVoteTimestamps;
    
    // --- State Variables for Vote-Specific Locking ---
    mapping(address => uint256) public tokenUnlockTimeForCeoVote;
    mapping(address => uint256) public tokenUnlockTimeForFundingVote;
    mapping(address => uint256) public lockedBalanceForCeoVote;
    mapping(address => uint256) public lockedBalanceForFundingVote;
    mapping(address => address) public votingDelegate;

    // Weighted-average acquisition timestamp of each holder's balance
    mapping(address => uint256) public balanceAge;

    using TokenHolderLib for TokenHolderLib.State;
    TokenHolderLib.State private _tokenHolderState;

    // --- Supply Tracking ---
    // Running total of tokens locked by voting snapshots (sum of lockedBalanceRequirement for active locks)
    uint256 public totalLockedTokens;

    // --- Hooks required by ExchangeManager ---
    function _totalSupply() internal view override returns (uint256) {
        return totalSupply();
    }

    // Vesting removed: no vested-supply hook required.

    function _getTotalTokensLocked() internal view override returns (uint256) {
        return totalLockedTokens;
    }

    function _balanceOfForVotes(address account) internal view override returns (uint256) {
        // Decoupled from locks: full balance counts toward delegated voting power.
        return balanceOf(account);
    }

    modifier onlyWhitelisted() {
        if (!whitelistManager.isWhitelisted(msg.sender)) revert Errors.NotWhitelisted();
        _;
    }

    modifier onlyEndorser() {
        if (!isEndorser[msg.sender]) revert Errors.OnlyEndorser();
        _;
    }

    // --- Proposal Structs (Mappings Removed) ---

    struct CeoApplication {
        address applicant;
        uint256 endorserVotes;
        uint256 userVotesFor;
        uint256 userVotesAgainst;
        uint256 deadline;
        ProposalLib.ProposalStatus status;
    }

    // --- Events ---
    // Events are declared in EventLib.sol

    /**
     * @dev Initializes all parent contracts and sets up initial DAO state.
     */
    constructor(
        address _priceFeedAddress,
        address _initialCeo,
        address[] memory _initialEndorsers,
        address _treasuryOwner,
        address _invUsdToken,
        address _whitelistManager,
        address _fundingManager
    )
        ERC20("INVTRON", "INV")
        EIP712("INVTRON", "1")
    {
        invUsdToken = InvUsdToken(_invUsdToken);
        whitelistManager = WhitelistManager(_whitelistManager);
        fundingManager = IFundingManager(_fundingManager);

        _setCeo(_initialCeo);
        if (_initialEndorsers.length > MAX_ACTIVE_ENDORSERS) {
            revert Errors.TooManyInitialEndorsers();
        }
        for (uint256 i = 0; i < _initialEndorsers.length; i++) {
            isEndorser[_initialEndorsers[i]] = true;
            endorserCandidates[_initialEndorsers[i]].registered = true;
            endorserCandidates[_initialEndorsers[i]].active = true;
            _activeEndorserList.push(_initialEndorsers[i]);
        }
        // lowestActiveEndorser left default to save code size

        // Set external feeds
        priceFeed = AggregatorV3Interface(_priceFeedAddress);
        treasuryOwner = _treasuryOwner;
        lastPrice = PriceLib.getLatestPrice(priceFeed);

        // Mint initial governance token supply (1 billion tokens as per white paper)
        _mint(msg.sender, 1_000_000_000 * 10**decimals());
    }

    // --- Manager hooks for FundingManagerContract ---
    function getLatestUsdPrice() external view returns (int) {
        return PriceLib.getLatestPrice(priceFeed);
    }

    function prepareFundingVote(address caller, address tokenHolder) external returns (address voter) {

        if (msg.sender != address(fundingManager)) revert Errors.OnlyFundingManager();
        (voter, ) = VotingLib.prepareDelegatedVote(
            votingDelegate,
            tokenUnlockTimeForFundingVote, // Use funding-specific unlock time
            recentVoteTimestamps,
            getVotes,
            TOKEN_LOCK_DURATION,
            caller,
            tokenHolder
        );
    }

    function lockTokensForFunding(address voter, uint256 amount) external {
        if (msg.sender != address(fundingManager)) revert Errors.OnlyFundingManager();
        _snapshotLock(voter, amount, VoteType.Funding);
    }

    function getDelegate(address voter) external view returns (address) {
        return votingDelegate[voter];
    }

    function mintGovByManager(address to, uint256 amount) external {
        if (msg.sender != address(fundingManager)) revert Errors.OnlyFundingManager();
        if (to == address(0) || amount == 0) return; // safe no-op
        _mint(to, amount);
    }

    function mintInvUsdByManager(address to, uint256 amount) external {
        if (msg.sender != address(fundingManager)) revert Errors.OnlyFundingManager();
        invUsdToken.mint(to, amount);
    }

    function seedExchangeRemaining(uint256 id, uint256 amount) external {
        if (msg.sender != address(fundingManager)) revert Errors.OnlyFundingManager();
        remainingToExchange[id] = amount;
    }

    function collectInvFee(address from, uint256 amount) external {
        if (msg.sender != address(fundingManager)) revert Errors.OnlyFundingManager();
        _spendAllowance(from, address(this), amount);
        _transfer(from, treasuryOwner, amount);
    }

    // --- Role Management & Applications ---

    /// @notice Update the address that collects application fees.
    /// @param newOwner The new treasury address.
    function setTreasuryOwner(address newOwner) external onlyCEO {
        if (newOwner == address(0)) revert Errors.TreasuryOwnerZero();
        treasuryOwner = newOwner;
    }

    // Note: vesting accounting fully removed.


    /// @notice Submit yourself as a candidate for the CEO role.
    /// @dev Requires the caller to be whitelisted and to hold a minimum amount
    ///      of INV tokens equivalent to $25,000.
    function applyForCeo() external {
        if (!whitelistManager.isWhitelisted(msg.sender)) revert Errors.ApplicantNotWhitelisted();
        if (electedCeo != address(0)) revert Errors.ElectedCeoPending();
        if (ceoStatus[msg.sender] != CeoStatus.None) revert Errors.CeoApplicationExists();

        int currentPrice = PriceLib.getLatestPrice(priceFeed);
        uint256 userValue = (balanceOf(msg.sender) * uint256(currentPrice)) / 1e18;
        if (userValue < CEO_REQUIRED_BALANCE_USD) revert Errors.InsufficientInvBalance();

        uint256 feeInInv = (CEO_APPLICATION_FEE * 1e18) / uint256(currentPrice);

        _spendAllowance(msg.sender, address(this), feeInInv);
        _transfer(msg.sender, treasuryOwner, feeInInv);

        uint256 id = nextCeoApplicationId++;
        CeoApplication storage app = ceoApplications[id];
        app.applicant = msg.sender;
        app.deadline = block.timestamp + VOTING_PERIOD;
        app.status = ProposalLib.ProposalStatus.Pending;
        activeCeoApplication[msg.sender] = id;
        ceoStatus[msg.sender] = CeoStatus.Nominated;
        emit EventLib.CeoApplicationCreated(id, msg.sender);
    }

    // --- Funding Requests ---
    // moved to FundingManagerContract

    // --- Endorser Leaderboard ---

    /// @notice Register the caller as a potential endorser candidate.
    /// @dev Charges a small application fee which is sent to the treasury.
    function registerEndorserCandidate() external onlyWhitelisted {
        int currentPrice = PriceLib.getLatestPrice(priceFeed);
        uint256 userValue = (balanceOf(msg.sender) * uint256(currentPrice)) / 1e18;
        if (userValue < ENDORSER_REQUIRED_BALANCE_USD) revert Errors.InsufficientInvBalance();
        uint256 feeInInv = (ENDORSER_APPLICATION_FEE * 1e18) / uint256(currentPrice);
        _spendAllowance(msg.sender, address(this), feeInInv);
        _transfer(msg.sender, treasuryOwner, feeInInv);

        EndorserLib.PersonalInfo memory info = whitelistManager
            .getWhitelistInfo(msg.sender);
        EndorserLib.registerCandidate(endorserCandidates, msg.sender, info);
    }

    /// @notice Vote for an endorser candidate using the caller's voting power.
    /// @param candidate Address of the candidate being supported.
    function voteForEndorser(address candidate) external {
        if (msg.sender == candidate) revert Errors.SelfVoting();
        uint256 weight = EndorserLib.voteForCandidate(
            endorserCandidates,
            endorserVotes,
            msg.sender,
            candidate,
            balanceOf,
            endorserSupport,
            endorserVoterWeight
        );
        // No delegation occurs here; endorsement support is tracked separately
        emit EndorserLib.EndorserVoteChanged(msg.sender, candidate, weight);
    }

    function delegate(address delegatee) public override {
        bool isCeoLocked = block.timestamp < tokenUnlockTimeForCeoVote[msg.sender];
        bool isFundingLocked = block.timestamp < tokenUnlockTimeForFundingVote[msg.sender];
        if (isCeoLocked || isFundingLocked) revert Errors.TokensLocked();
        _enforceDelegationRestrictions(msg.sender, delegatee);
        _delegate(msg.sender, delegatee);
    }

    function nonces(address owner) external view returns (uint256) {
        return _nonces[owner];
    }

    function _useNonce(address owner) internal returns (uint256 current) {
        current = _nonces[owner];
        _nonces[owner] = current + 1;
    }

    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        if (block.timestamp > expiry) revert Errors.SignatureExpired();

        // Recover signer and validate nonce
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        address signer = ECDSA.recover(_hashTypedDataV4(structHash), v, r, s);
        if (nonce != _useNonce(signer)) revert Errors.InvalidNonce();

        // Block delegation while locked
        bool isCeoLocked = block.timestamp < tokenUnlockTimeForCeoVote[signer];
        bool isFundingLocked = block.timestamp < tokenUnlockTimeForFundingVote[signer];
        if (isCeoLocked || isFundingLocked) revert Errors.TokensLocked();
        _enforceDelegationRestrictions(signer, delegatee);
        _delegate(signer, delegatee);
    }

    /// @notice Delegate voting power using an EIP-712 signature.
    /// @param delegatee Address receiving the voting power.
    /// @param nonce Current nonce of the signer.
    /// @param deadline Expiration time of the signature.
    /// @param v Signature parameter v.
    /// @param r Signature parameter r.
    /// @param s Signature parameter s.
    function delegateVPbySig(
        address delegatee,
        uint256 nonce,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        if (block.timestamp > deadline) revert Errors.SignatureExpired();

        // Pre-recover signer for the lock check (do not consume nonce here)
        bytes32 structHash = keccak256(abi.encode(DELEGATE_VP_TYPEHASH, delegatee, nonce, deadline));
        address signer = ECDSA.recover(_hashTypedDataV4(structHash), v, r, s);

        bool isCeoLocked = block.timestamp < tokenUnlockTimeForCeoVote[signer];
        bool isFundingLocked = block.timestamp < tokenUnlockTimeForFundingVote[signer];
        if (isCeoLocked || isFundingLocked) revert Errors.TokensLocked();

        // Enforce delegation restrictions for vote-by-proxy mapping as well
        _enforceDelegationRestrictions(signer, delegatee);

        // Proceed with existing flow; DelegateLib will consume nonce
        DelegateLib.delegateBySig(
            votingDelegate,
            DELEGATE_VP_TYPEHASH,
            _hashTypedDataV4,
            _useNonce,
            delegatee,
            nonce,
            deadline,
            v,
            r,
            s
        );
    }

    /// @notice Attempt to join the active endorser set by displacing the weakest member.
    /// @param candidate Address of the registered candidate trying to join.
    function challengeEndorser(address candidate) external {
        address replaced = EndorserLib.challengeCandidate(
            endorserCandidates,
            _activeEndorserList,
            candidate,
            MAX_ACTIVE_ENDORSERS,
            endorserSupport
        );
        if (replaced != address(0)) {
            isEndorser[replaced] = false;
        }
        isEndorser[candidate] = true;
    }


    /**
     * @dev Returns the full list of active endorsers.
     */
    function activeEndorserList() external view returns (address[] memory) {
        return _activeEndorserList;
    }

    // --- Voting Functions ---

    /// @notice Endorsers cast their vote on a pending CEO application.
    /// @param id Identifier of the CEO application.
    function voteOnCeoByEndorser(uint256 id) external onlyEndorser {
        CeoApplication storage app = ceoApplications[id];
        if (app.status != ProposalLib.ProposalStatus.Pending) revert Errors.CeoProposalNotPending();
        if (block.timestamp >= app.deadline) {
            app.status = ProposalLib.ProposalStatus.Defeated;
            ceoStatus[app.applicant] = CeoStatus.None;
            activeCeoApplication[app.applicant] = 0;
            emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Defeated));
            revert Errors.CeoVotingEnded();
        }
        if (ceoEndorsersVoted[id][msg.sender]) revert Errors.EndorserAlreadyVoted();
        ceoEndorsersVoted[id][msg.sender] = true;
        app.endorserVotes++;
        if (app.endorserVotes >= ENDORSER_VOTES_FOR_CEO_PASS) {
            app.status = ProposalLib.ProposalStatus.Active;
            app.deadline = block.timestamp + VOTING_PERIOD;
            emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Active));
        }
    }

    // Funding endorser voting moved to FundingManagerContract

    /// @notice Expire a pending CEO application if the deadline has passed without enough endorser votes.
    function expireCeoApplication(uint256 id) external {
        CeoApplication storage app = ceoApplications[id];
        if (app.status != ProposalLib.ProposalStatus.Pending) revert Errors.CeoProposalNotPending();
        if (block.timestamp < app.deadline) revert Errors.CeoVotingActive();
        app.status = ProposalLib.ProposalStatus.Defeated;
        ceoStatus[app.applicant] = CeoStatus.None;
        activeCeoApplication[app.applicant] = 0;
        emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Defeated));
    }

    // Funding expiry moved to FundingManagerContract

    /// @notice Cast a user vote on an active CEO application.
    /// @param id Identifier of the CEO application.
    /// @param inFavor True to vote in favour, false to vote against.
    /// @param tokenHolder Address whose voting power is used (can be a delegate).
    function voteOnCeoByUser(uint256 id, bool inFavor, address tokenHolder) external {
        CeoApplication storage app = ceoApplications[id];
        if (app.status != ProposalLib.ProposalStatus.Active) revert Errors.CeoProposalNotActive();
        if (block.timestamp >= app.deadline) revert Errors.CeoVotingEnded();
        (address voter, uint256 powerRaw) = VotingLib.prepareDelegatedVote(
            votingDelegate,
            tokenUnlockTimeForCeoVote, // Use CEO-specific unlock time
            recentVoteTimestamps,
            getVotes,
            TOKEN_LOCK_DURATION,
            msg.sender,
            tokenHolder
        );
        // Clamp by cross-type headroom so each vote that counts must secure lock.
        uint256 head = freeHeadroomTokens(voter);
        uint256 power = powerRaw > head ? head : powerRaw;
        if (power == 0) {
            if (powerRaw > 0) revert Errors.TokensLocked();
            revert Errors.NoVotingPower();
        }

        // Disallow self-vote before touching locks (gas/clarity)
        if (app.applicant == voter) revert Errors.SelfVoting();
        if (ceoUsersVoted[id][voter]) revert Errors.CeoUserAlreadyVoted();

        // Take snapshot lock exactly for the applied amount
        _snapshotLock(voter, power, VoteType.Ceo);
        ceoUsersVoted[id][voter] = true;
        if (inFavor) app.userVotesFor += power;
        else app.userVotesAgainst += power;
        emit EventLib.Voted(id, voter, inFavor, power);
    }

    function _snapshotLock(address voter, uint256 amount, VoteType voteType) internal {
        // If an old lock expired, drop it from the running total
        uint256 prevReq;
        uint256 unlockTime;

        if (voteType == VoteType.Ceo) {
            prevReq = lockedBalanceForCeoVote[voter];
            unlockTime = tokenUnlockTimeForCeoVote[voter];
        } else { // VoteType.Funding
            prevReq = lockedBalanceForFundingVote[voter];
            unlockTime = tokenUnlockTimeForFundingVote[voter];
        }
        if (prevReq != 0 && block.timestamp >= unlockTime) {
            totalLockedTokens -= prevReq;
            prevReq = 0;
            if (voteType == VoteType.Ceo) {
                lockedBalanceForCeoVote[voter] = 0;
            } else {
                lockedBalanceForFundingVote[voter] = 0;
            }
        }
        // Also clear an expired OTHER-TYPE lock to avoid over-clamping this vote.
        uint256 otherReq;
        uint256 otherUnlock;
        if (voteType == VoteType.Ceo) {
            otherReq = lockedBalanceForFundingVote[voter];
            otherUnlock = tokenUnlockTimeForFundingVote[voter];
            if (otherReq != 0 && block.timestamp >= otherUnlock) {
                totalLockedTokens -= otherReq;
                lockedBalanceForFundingVote[voter] = 0;
                otherReq = 0;
            }
        } else {
            otherReq = lockedBalanceForCeoVote[voter];
            otherUnlock = tokenUnlockTimeForCeoVote[voter];
            if (otherReq != 0 && block.timestamp >= otherUnlock) {
                totalLockedTokens -= otherReq;
                lockedBalanceForCeoVote[voter] = 0;
                otherReq = 0;
            }
        }
        // Prevent cross-type over-lock: cap by remaining headroom across both types.
        uint256 bal = balanceOf(voter);
        uint256 used = prevReq + otherReq;
        uint256 available = bal > used ? bal - used : 0;
        if (amount > available) amount = available;
        // Prevent "free vote": if caller requested a positive lock but headroom is zero, revert.
        if (amount == 0) revert Errors.TokensLocked();
        if (amount > 0) {
            totalLockedTokens += amount;
            if (voteType == VoteType.Ceo) {
                lockedBalanceForCeoVote[voter] = prevReq + amount;
            } else {
                lockedBalanceForFundingVote[voter] = prevReq + amount;
            }
        }
    }

    /// @notice Clear your expired voting lock to restore full transferability.
    function unlockYourTokens() external {
        address sender = msg.sender;
        // Check and clear expired CEO vote lock
        uint256 ceoReq = lockedBalanceForCeoVote[sender];
        if (ceoReq > 0 && block.timestamp >= tokenUnlockTimeForCeoVote[sender]) {
            totalLockedTokens -= ceoReq;
            lockedBalanceForCeoVote[sender] = 0;
        }

        // Check and clear expired Funding vote lock
        uint256 fundingReq = lockedBalanceForFundingVote[sender];
        if (fundingReq > 0 && block.timestamp >= tokenUnlockTimeForFundingVote[sender]) {
            totalLockedTokens -= fundingReq;
            lockedBalanceForFundingVote[sender] = 0;
        }
    }

    // --- Finalization ---

    /// @notice Conclude an active CEO election once its voting period has ended.
    /// @param id Identifier of the CEO application.
    function finalizeCeoVote(uint256 id) external {
        CeoApplication storage app = ceoApplications[id];
        if (app.status != ProposalLib.ProposalStatus.Active) revert Errors.CeoProposalNotActiveFinalization();
        if (block.timestamp < app.deadline) revert Errors.CeoVotingActive();

        if (app.userVotesFor > app.userVotesAgainst) {
            app.status = ProposalLib.ProposalStatus.Succeeded;
            ceoStatus[app.applicant] = CeoStatus.Elected;
            electedCeo = app.applicant;
            electedCeoTimestamp = block.timestamp;
        } else {
            app.status = ProposalLib.ProposalStatus.Defeated;
            ceoStatus[app.applicant] = CeoStatus.None;
        }
        activeCeoApplication[app.applicant] = 0;
        emit EventLib.ProposalStatusUpdated(id, uint8(app.status));
    }

    // Funding finalization moved to FundingManagerContract

    /// @notice Activate the elected CEO after the mandatory waiting period.
    function activateElectedCeo() external {
        if (electedCeo == address(0)) revert Errors.NoElectedCeo();
        if (block.timestamp < electedCeoTimestamp + ELECTED_CEO_ACTIVATION_DELAY) {
            revert Errors.ActivationNotReached();
        }
        address newCeo = electedCeo;
        electedCeo = address(0);
        ceoStatus[newCeo] = CeoStatus.Active;
        _setCeo(newCeo);
    }

    // Funding release, execution and rewards moved to FundingManagerContract


    // --- Exchange & Admin ---

    /// @notice Limit how much INV-USD can be converted back to INV each day for a request.
    /// @param requestId The funding request to configure.
    /// @param limitPercent Percentage of the total amount that may be exchanged per day.
    // --- Helpers ---

    /// @notice Calculate the total amount of tokens currently locked for voting.
    /// @dev Running counter updated on vote snapshots and on expiries observed during transfers.
    function getTotalTokensLocked() public view returns (uint256 total) {
        return totalLockedTokens;
    }

    // Intentionally no on-chain enumeration of holders; totals update lazily on activity.

    /// @notice Return the number of tokens currently in circulation.
    /// @dev Circulating supply excludes tokens locked by voting snapshots.
    function getCirculatingSupply() external view returns (uint256) {
        return totalSupply() - totalLockedTokens;
    }
    
    // --- Required Multi-Inheritance Overrides ---

    function _daoMint(address account, uint256 amount) internal override {
        _mint(account, amount);
    }

    function _update(address from, address to, uint256 amount) internal override {
        uint256 oldFrom;
        uint256 oldTo;

        if (from != address(0)) {
            oldFrom = balanceOf(from);
            uint256 fromCeoReq = lockedBalanceForCeoVote[from];
            uint256 fromFundingReq = lockedBalanceForFundingVote[from];
            uint256 ceoUnlock = tokenUnlockTimeForCeoVote[from];
            uint256 fundingUnlock = tokenUnlockTimeForFundingVote[from];

            // Lazily clear expired locks from totals only; voting power stays decoupled.
            // Clear per type individually (no maxUnlockTime gate) so metrics stay fresh.
            if (fromCeoReq != 0 && block.timestamp >= ceoUnlock) {
                totalLockedTokens -= fromCeoReq;
                lockedBalanceForCeoVote[from] = 0;
            }
            if (fromFundingReq != 0 && block.timestamp >= fundingUnlock) {
                totalLockedTokens -= fromFundingReq;
                lockedBalanceForFundingVote[from] = 0;
            }
        }
        if (to != address(0)) {
            oldTo = balanceOf(to);
        }

        if (from != address(0)) {
            // During the lock window, allow spending only the excess over the required minimum
            uint256 totalRequired = lockedBalanceForCeoVote[from] + lockedBalanceForFundingVote[from];
            uint256 latestUnlock = tokenUnlockTimeForCeoVote[from] > tokenUnlockTimeForFundingVote[from] ? tokenUnlockTimeForCeoVote[from] : tokenUnlockTimeForFundingVote[from];
            if (block.timestamp < latestUnlock && totalRequired > 0) {
                // Disallow spending from the locked (snapshot) portion
                uint256 allowed = oldFrom > totalRequired ? oldFrom - totalRequired : 0;
                if (amount > allowed) revert Errors.TokensLocked();
            }
        }

        super._update(from, to, amount);

        // If a voter previously supported an endorser, reduce their recorded
        // support when their balance decreases due to a transfer/burn.
        if (from != address(0)) {
            uint256 newFrom = balanceOf(from);
            if (newFrom < oldFrom) {
                uint256 delta = oldFrom - newFrom;
                address supported = endorserVotes[from];
                if (supported != address(0)) {
                    uint256 prevWeight = endorserVoterWeight[from];
                    uint256 reduce = delta > prevWeight ? prevWeight : delta;
                    if (reduce > 0) {
                        endorserVoterWeight[from] = prevWeight - reduce;
                        uint256 prevSupport = endorserSupport[supported];
                        endorserSupport[supported] = prevSupport >= reduce ? (prevSupport - reduce) : 0;
                        // convenience tracker not updated here to save code size
                    }
                }
            }
        }

        // Cache delegates once for minimal SLOADs
        address fromDel;
        address toDel;
        if (from != address(0) && to != address(0)) {
            fromDel = delegates(from);
            toDel = delegates(to);
        }

        if (from != address(0)) {
            uint256 newFrom = balanceOf(from);
            // Optimize voting power writes: if both sides delegate to the same address, net change is zero
            if (!(from != address(0) && to != address(0) && fromDel == toDel)) {
                _afterTokenBalanceChange(from, oldFrom, newFrom);
            }
            if (newFrom == 0) {
                balanceAge[from] = 0;
                _tokenHolderState.removeTokenHolder(from);
            }
        }
        if (to != address(0)) {
            uint256 newTo = balanceOf(to);
            if (!(from != address(0) && to != address(0) && fromDel == toDel)) {
                _afterTokenBalanceChange(to, oldTo, newTo);
            }
            if (newTo > 0) {
                _tokenHolderState.addTokenHolder(to);
            }
            if (newTo > oldTo) {
                uint256 inc = newTo - oldTo;
                uint256 prevAge = balanceAge[to];
                // weighted-average age of incoming balance
                balanceAge[to] = (prevAge * oldTo + block.timestamp * inc) / newTo;

                // If receiver previously supported an endorser, increase their recorded support
                address supportedTo = endorserVotes[to];
                if (supportedTo != address(0)) {
                    endorserVoterWeight[to] += inc;
                    endorserSupport[supportedTo] += inc;
                    // convenience tracker not updated here to save code size
                }
            }
        }
    }

    function getPastVotes(address account, uint256) public view returns (uint256) {
        return getVotes(account);
    }

    // getPastTotalSupply removed to reduce code size

    // --- Compatibility Shims ---

    function CEO_ROLE() public pure returns (bytes32) {
        return keccak256("CEO_ROLE");
    }

    function ENDORSER_ROLE() public pure returns (bytes32) {
        return keccak256("ENDORSER_ROLE");
    }

    function hasRole(bytes32 role, address account) external view returns (bool) {
        if (role == CEO_ROLE()) return account == currentCeo;
        if (role == ENDORSER_ROLE()) return isEndorser[account];
        return false;
    }

    /// @notice Allow an endorser to renounce their role.
    function renounceEndorserShip() external onlyEndorser {
        // Always remove the core role for any endorser
        isEndorser[msg.sender] = false;

        // If the endorser was active, also clean up their active status and remove them from the list
        if (endorserCandidates[msg.sender].active) {
            endorserCandidates[msg.sender].active = false;

            // Remove from active list
            for (uint256 i = 0; i < _activeEndorserList.length; i++) {
                if (_activeEndorserList[i] == msg.sender) {
                    _activeEndorserList[i] = _activeEndorserList[_activeEndorserList.length - 1];
                    _activeEndorserList.pop();
                    break;
                }
            }
        }
        // Endorser renounced; no event to minimize code size
    }

    // --- Internal helpers ---
    function _enforceDelegationRestrictions(address delegator, address delegatee) internal view {
        // Always allow self-delegation to overwrite existing choices
        if (delegatee == delegator) return;
        // CEOs (Nominated, Elected, Active) cannot delegate to others
        CeoStatus status = ceoStatus[delegator];
        if (status == CeoStatus.Nominated || status == CeoStatus.Elected || status == CeoStatus.Active) {
            revert Errors.CeoCannotDelegateToOthers();
        }
        // Endorsers cannot delegate to others
        if (isEndorser[delegator]) {
            revert Errors.EndorserCannotDelegateToOthers();
        }
    }
}

Contract: InvUsdToken
Source: contracts/InvUsdToken.sol
Address: 0x4dEbFe9c72B478C347ebeF3588622971Dffb9Ee7
Code:
//InvUsdToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./libraries/Errors.sol";

/**
 * @title InvUsdToken
 * @dev ERC20 token for INV-USD, owned by the DAO and restricted to interactions with it.
 */
contract InvUsdToken is ERC20 {
    address public owner;

    constructor() ERC20("INVTRON USD", "INV-USD") {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) revert Errors.OnlyDao();
        _;
    }

    function transferOwnership(address newOwner) external onlyOwner {
        if (newOwner == address(0)) revert Errors.NewOwnerZero();
        owner = newOwner;
    }

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    function burnFrom(address from, uint256 amount) external onlyOwner {
        _burn(from, amount);
    }

    /**
     * @dev Overrides the core _update function to enforce spending restrictions.
     * INV-USD can only be transferred back to the DAO contract that owns it.
     * This prevents user-to-user trading and keeps it as a utility voucher.
     */
    function _update(address from, address to, uint256 amount) internal virtual override {
        if (from != address(0) && to != address(0)) {
            if (msg.sender != owner) {
                if (to != owner) revert Errors.InvalidExchangeRecipient();
            }
        }
        super._update(from, to, amount);
    }
}

Contract: MockV3Aggregator
Source: contracts/MockV3Aggregator.sol
Address: N/A
Code:
// MockV3Aggregator.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract MockV3Aggregator {
    uint8 public decimals;
    int256 private _answer;
    uint256 private _timestamp;

    constructor(uint8 _decimals, int256 answer_) {
        decimals = _decimals;
        _answer = answer_;
        _timestamp = block.timestamp;
    }

    function setLatestData(int256 answer_, uint256 timestamp_) external {
        _answer = answer_;
        _timestamp = timestamp_;
    }

    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    ) {
        return (0, _answer, 0, _timestamp, 0);
    }
}

Contract: WhitelistManager
Source: contracts/WhitelistManager.sol
Address: 0x6096055C83567F43431001CF304E72602dce356a
Code:
//WhitelistManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./libraries/WhitelistLib.sol";
import "./libraries/EventLib.sol";
import "./libraries/EndorserLib.sol";
import "./libraries/Errors.sol";
import "./INVTRON_DAO.sol";

contract WhitelistManager {
    address public dao;

    mapping(address => bool) private _whitelisted;
    uint256 public nextWhitelistRequestId;
    mapping(uint256 => WhitelistLib.Request) public whitelistRequests;
    mapping(address => uint256) public lastWhitelistRequest;
    uint256[] private _pendingWhitelistRequests;
    mapping(address => EndorserLib.PersonalInfo) public whitelistInfo;

    function setDao(address _dao) external {
        if (dao != address(0)) revert Errors.DaoAlreadySet();
        if (_dao == address(0)) revert Errors.DaoAddressZero();
        dao = _dao;
    }

    function _onlyCeo() internal view {
        if (!INVTRON_DAO(dao).hasRole(INVTRON_DAO(dao).CEO_ROLE(), msg.sender)) {
            revert Errors.OnlyCeo();
        }
    }

    function makeWhitelisted(address user, bool value) external {
        _onlyCeo();
        _whitelisted[user] = value;
        if (value) {
            emit EventLib.Whitelisted(user);
        } else {
            lastWhitelistRequest[user] = 0;
        }
    }

    function isWhitelisted(address user) external view returns (bool) {
        return _whitelisted[user];
    }

    function requestWhitelisting(EndorserLib.PersonalInfo calldata info) external {
        if (_whitelisted[msg.sender]) revert Errors.AlreadyWhitelisted();
        uint256 existingId = lastWhitelistRequest[msg.sender];
        if (existingId != 0) {
            WhitelistLib.Request storage existing = whitelistRequests[existingId];
            if (
                existing.status == WhitelistLib.RequestStatus.Pending ||
                existing.status == WhitelistLib.RequestStatus.Approved
            ) {
                revert Errors.WhitelistRequestExists();
            }
        }
        uint256 id = ++nextWhitelistRequestId;
        whitelistRequests[id] = WhitelistLib.Request({
            applicant: msg.sender,
            info: info,
            status: WhitelistLib.RequestStatus.Pending
        });
        whitelistInfo[msg.sender] = info;
        lastWhitelistRequest[msg.sender] = id;
        _pendingWhitelistRequests.push(id);
    }

    function getWhitelistingReqStatus(address user) external view returns (WhitelistLib.RequestStatus) {
        uint256 id = lastWhitelistRequest[user];
        if (id == 0) revert Errors.NoWhitelistRequest();
        return whitelistRequests[id].status;
    }

    function getWwhitelistReqList() external view returns (WhitelistLib.Request[] memory) {
        uint256 count = _pendingWhitelistRequests.length;
        WhitelistLib.Request[] memory list = new WhitelistLib.Request[](count);
        for (uint256 i = 0; i < count; i++) {
            list[i] = whitelistRequests[_pendingWhitelistRequests[i]];
        }
        return list;
    }

    function getWhitelistInfo(address user) external view returns (EndorserLib.PersonalInfo memory) {
        return whitelistInfo[user];
    }

    function ceoApproveWhitelisting(
        address[] calldata wallets,
        uint256[] calldata ids,
        bool approve
    ) external {
        _onlyCeo();
        if (wallets.length > 0) {
            for (uint256 i = 0; i < wallets.length; i++) {
                uint256 id = lastWhitelistRequest[wallets[i]];
                _processWhitelist(id, wallets[i], approve);
            }
        } else {
            for (uint256 i = 0; i < ids.length; i++) {
                WhitelistLib.Request storage req = whitelistRequests[ids[i]];
                _processWhitelist(ids[i], req.applicant, approve);
            }
        }
    }

    function _processWhitelist(uint256 id, address user, bool approve) internal {
        if (id == 0) revert Errors.NoWhitelistRequest();
        WhitelistLib.Request storage req = whitelistRequests[id];
        if (req.status != WhitelistLib.RequestStatus.Pending) revert Errors.WhitelistRequestNotPending();
        if (approve) {
            req.status = WhitelistLib.RequestStatus.Approved;
            _whitelisted[user] = true;
            emit EventLib.Whitelisted(user);
        } else {
            req.status = WhitelistLib.RequestStatus.Rejected;
        }
        WhitelistLib.removePending(_pendingWhitelistRequests, id);
    }
}

Library: DelegateLib
Source: contracts/libraries/DelegateLib.sol
Address: N/A
Code:
//libraries/DelegateLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./Errors.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

library DelegateLib {
    event VotingPowerDelegated(address indexed delegator, address indexed delegatee);

    function delegateBySig(
        mapping(address => address) storage delegateMap,
        bytes32 typehash,
        function(bytes32) internal view returns (bytes32) hashTypedDataV4Func,
        function(address) internal returns (uint256) useNonceFunc,
        address delegatee,
        uint256 nonce,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        if (block.timestamp > deadline) revert Errors.SignatureExpired();
        bytes32 structHash = keccak256(abi.encode(typehash, delegatee, nonce, deadline));
        address signer = ECDSA.recover(hashTypedDataV4Func(structHash), v, r, s);
        if (nonce != useNonceFunc(signer)) revert Errors.InvalidNonce();
        delegateMap[signer] = delegatee;
        emit VotingPowerDelegated(signer, delegatee);
    }
}

Library: EndorserLib
Source: contracts/libraries/EndorserLib.sol
Address: N/A
Code:
//libraries/EndorserLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./VotingLib.sol";
import "./Errors.sol";

library EndorserLib {
    using VotingLib for address[];

    struct PersonalInfo {
        string firstName;
        string lastName;
        string mobile;
        string zipCode;
        string city;
        string state;
        string country;
        string bio;
    }

    struct EndorserCandidate {
        bool registered;
        bool active;
        PersonalInfo info;
    }

    event EndorserCandidateRegistered(address indexed candidate);
    event EndorserVoteChanged(address indexed voter, address indexed candidate, uint256 weight);
    event EndorserChallengeSuccess(address indexed candidate, address indexed replaced);

    function registerCandidate(
        mapping(address => EndorserCandidate) storage candidates,
        address candidateAddr,
        PersonalInfo memory info
    ) internal {
        if (candidates[candidateAddr].registered) revert Errors.AlreadyRegistered();
        EndorserCandidate storage cand = candidates[candidateAddr];
        cand.registered = true;
        cand.info = info;
        emit EndorserCandidateRegistered(candidateAddr);
    }

    function voteForCandidate(
        mapping(address => EndorserCandidate) storage candidates,
        mapping(address => address) storage votes,
        address voter,
        address candidate,
        function(address) view returns (uint256) weightOf,
        mapping(address => uint256) storage supportByCandidate,
        mapping(address => uint256) storage lastVoterWeight
    ) internal returns (uint256 weight) {
        if (!candidates[candidate].registered) revert Errors.CandidateNotRegistered();
        weight = weightOf(voter);
        if (weight == 0) revert Errors.NoVotingPower();

        address prev = votes[voter];
        uint256 prevW = lastVoterWeight[voter];
        if (prev != address(0) && prevW != 0) {
            uint256 prevSupport = supportByCandidate[prev];
            supportByCandidate[prev] = prevSupport >= prevW ? (prevSupport - prevW) : 0;
        }

        votes[voter] = candidate;
        lastVoterWeight[voter] = weight;
        supportByCandidate[candidate] += weight;
    }

    function challengeCandidate(
        mapping(address => EndorserCandidate) storage candidates,
        address[] storage activeList,
        address candidate,
        uint256 maxActive,
        mapping(address => uint256) storage supportByCandidate
    ) internal returns (address replaced) {
        if (!candidates[candidate].registered) revert Errors.CandidateNotRegistered();
        if (candidates[candidate].active) revert Errors.CandidateAlreadyActive();

        if (activeList.length < maxActive) {
            activeList.push(candidate);
            candidates[candidate].active = true;
            emit EndorserChallengeSuccess(candidate, address(0));
            return (address(0));
        }

        address weakest = activeList[0];
        uint256 weakestVotes = supportByCandidate[weakest];
        for (uint256 i = 1; i < activeList.length; i++) {
            address current = activeList[i];
            uint256 votes = supportByCandidate[current];
            if (votes < weakestVotes) {
                weakestVotes = votes;
                weakest = current;
            }
        }
        if (supportByCandidate[candidate] <= supportByCandidate[weakest]) revert Errors.NotEnoughVotes();

        for (uint256 i = 0; i < activeList.length; i++) {
            if (activeList[i] == weakest) {
                activeList[i] = candidate;
                break;
            }
        }
        candidates[weakest].active = false;
        candidates[candidate].active = true;
        emit EndorserChallengeSuccess(candidate, weakest);
        return (weakest);
    }
}

Library: Errors
Source: contracts/libraries/Errors.sol
Address: N/A
Code:
//libraries/Errors.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

library Errors {
    // InvUsdToken
    error OnlyDao();
    error InvalidExchangeRecipient();
    error NotWhitelisted();
    error DaoAlreadySet();
    error DaoAddressZero();
    error OnlyCeo();
    error OnlyEndorser();
    error OnlyFundingManager();
    error TooManyInitialEndorsers();
    error TreasuryOwnerZero();
    error InvalidFeedAddress();
    error ApplicantNotWhitelisted();
    error ElectedCeoPending();
    error CeoApplicationExists();
    error InsufficientInvBalance();
    error AlreadyRegistered();
    error CandidateNotRegistered();
    error NoVotingPower();
    error SignatureExpired();
    error InvalidNonce();
    error CandidateAlreadyActive();
    error NotEnoughVotes();
    error CeoProposalNotPending();
    error EndorserAlreadyVoted();
    error FundingProposalNotPending();
    error FundingEndorserAlreadyVoted();
    error CeoProposalNotActive();
    error CeoVotingEnded();
    error SelfVoting();
    error CeoUserAlreadyVoted();
    error FundingProposalNotActiveUser();
    error FundingVotingEnded();
    error FundingUserAlreadyVoted();
    error CeoProposalNotActiveFinalization();
    error CeoVotingActive();
    error NoElectedCeo();
    error ActivationNotReached();
    error FundingProposalNotActive();
    error FundingVotingActive();
    error FundingProposalFailed();
    error FundingProposalPassed();
    error FundingRequestAlreadyApproved();
    error FundingProposalNotActiveExecution();
    error FundingVotingActiveExecution();
    error FundingRequestNotApproved();
    error ProposalNotFinalized();
    error AddressDidNotVote();
    error RewardAlreadyClaimed();
    error VoteMismatch();
    error FundingRequestNotExecuted();
    error OnlyProposer();
    error ExchangeDisabled();
    error AmountExceedsRemaining();
    error ExceedsDailyLimit();
    error OracleStale();
    error OraclePriceInvalid();
    error OracleDecimalsTooLarge();
    error TokensLocked();
    error TokensAlreadyLocked();
    error InvalidTokenHolder();
    error NotAuthorizedDelegate();
    error AlreadyWhitelisted();
    error WhitelistRequestExists();
    error NoWhitelistRequest();
    error WhitelistRequestNotPending();
    error PriceOutOfBounds();
    error CeoSuccessorNotReady();
    error CeoSelfRevokeDenied();
    error UnswappedAmountExceedsTotal();
    error SupplyExceedsTotal();
    error NewOwnerZero();
    error InvalidLimitPercent();
    error InvalidFundingCaps();
    error InvalidValuation();
    // Delegation restrictions
    error CeoCannotDelegateToOthers();
    error EndorserCannotDelegateToOthers();
}

Library: EventLib
Source: contracts/libraries/EventLib.sol
Address: N/A
Code:
//libraries/EventLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

library EventLib {
    event Whitelisted(address indexed user);
    event CeoApplicationCreated(uint256 id, address applicant);
    event FundingRequestCreated(
        uint256 id,
        address proposer,
        string projectName,
        uint256 softCapAmount,
        uint256 hardCapAmount
    );
    event Voted(uint256 id, address voter, bool inFavor, uint256 votingPower);
    event ProposalStatusUpdated(uint256 id, uint8 status);
    event Exchanged(address indexed user, uint256 invUsdAmount, uint256 invAmount);
    event RewardClaimed(address indexed voter, uint256 amount);
    event DailyLimitSet(uint256 indexed requestId, uint256 newLimit);
    event FundingRequestApproved(uint256 indexed id);
    event TotalUnswappedUpdated(uint256 previousAmount, uint256 newAmount);
    event CeoChanged(address indexed previousCeo, address indexed newCeo);
    event PriceFeedUpdated(address indexed newFeed, int256 newPrice);
}

Library: FundingLib
Source: contracts/libraries/FundingLib.sol
Address: N/A
Code:
//libraries/FundingLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./ProposalLib.sol";
import "./EventLib.sol";
import "./Errors.sol";
import "../InvUsdToken.sol";

library FundingLib {
    using ProposalLib for ProposalLib.ProposalStatus;

    struct FundingDetails {
        string projectName;
        uint256 softCapAmount;
        uint256 hardCapAmount;
        uint256 valuation;
        string country;
        string websiteUrl;
        string ceoLinkedInUrl;
        string shortDescription;
        string companyRegistrationUrl;
    }

    struct FundingRequest {
        address proposer;
        FundingDetails details;
        uint256 amount;
        uint256 deadline;
        ProposalLib.ProposalStatus status;
        uint256 endorserVotes;
        uint256 userVotesFor;
        uint256 userVotesAgainst;
        bool ceoApproved;
    }

    struct State {
        uint256 nextFundingRequestId;
        mapping(uint256 => FundingRequest) fundingRequests;
    }

    function createFundingRequest(
        State storage state,
        address proposer,
        FundingDetails calldata details,
        uint256 votingPeriod
    ) internal returns (uint256 id) {
        id = state.nextFundingRequestId++;
        FundingRequest storage req = state.fundingRequests[id];
        req.proposer = proposer;
        req.details = details;
        req.amount = details.softCapAmount;
        req.deadline = block.timestamp + votingPeriod;
        req.status = ProposalLib.ProposalStatus.Pending;
        emit EventLib.FundingRequestCreated(
            id,
            proposer,
            details.projectName,
            details.softCapAmount,
            details.hardCapAmount
        );
    }

    function releaseFundingRequest(State storage state, uint256 id) internal {
        FundingRequest storage req = state.fundingRequests[id];
        if (req.status != ProposalLib.ProposalStatus.Active) revert Errors.FundingProposalNotActive();
        if (block.timestamp < req.deadline) revert Errors.FundingVotingActive();
        if (req.userVotesFor <= req.userVotesAgainst) revert Errors.FundingProposalFailed();
        if (req.ceoApproved) revert Errors.FundingRequestAlreadyApproved();
        req.ceoApproved = true;
        emit EventLib.FundingRequestApproved(id);
        emit EventLib.ProposalStatusUpdated(id, uint8(req.status));
    }

    function mintTokensForFundingRequest(
        State storage state,
        InvUsdToken token,
        mapping(uint256 => uint256) storage remainingToExchange,
        uint256 id
    ) internal returns (uint256 mintAmount) {
        FundingRequest storage req = state.fundingRequests[id];
        if (req.status != ProposalLib.ProposalStatus.Active) revert Errors.FundingProposalNotActiveExecution();
        if (block.timestamp < req.deadline) revert Errors.FundingVotingActiveExecution();
        if (req.userVotesFor <= req.userVotesAgainst) revert Errors.FundingProposalFailed();
        if (!req.ceoApproved) revert Errors.FundingRequestNotApproved();
        req.status = ProposalLib.ProposalStatus.Executed;
        mintAmount = req.amount * 1e12;
        token.mint(req.proposer, mintAmount);
        remainingToExchange[id] = mintAmount;
        emit EventLib.ProposalStatusUpdated(id, uint8(ProposalLib.ProposalStatus.Executed));
    }
}

Library: PriceLib
Source: contracts/libraries/PriceLib.sol
Address: N/A
Code:
//libraries/PriceLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {AggregatorV3Interface} from "../interfaces/AggregatorV3Interface.sol";
import "./Errors.sol";

library PriceLib {
    uint256 internal constant MAX_PRICE_AGE = 1 days;

    function getLatestPrice(
        AggregatorV3Interface feed
    ) internal view returns (int) {
        (
            ,
            int price,
            ,
            uint256 timeStamp,

        ) = feed.latestRoundData();
        if (timeStamp == 0 || block.timestamp - timeStamp > MAX_PRICE_AGE)
            revert Errors.OracleStale();
        if (price <= 0) revert Errors.OraclePriceInvalid();
        uint8 feedDecimals = feed.decimals();
        if (feedDecimals > 18) revert Errors.OracleDecimalsTooLarge();
        return price * int(10 ** (18 - feedDecimals));
    }

    function getInvValueInUsd(
        function(address) view returns (uint256) balanceOfFunc,
        AggregatorV3Interface feed,
        address user
    ) internal view returns (uint256) {
        int latestPrice = getLatestPrice(feed);
        return (balanceOfFunc(user) * uint256(latestPrice)) / 1e18;
    }
}

Library: ProposalLib
Source: contracts/libraries/ProposalLib.sol
Address: N/A
Code:
//libraries/ProposalLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

library ProposalLib {
    enum ProposalStatus { Pending, Active, Succeeded, Defeated, Executed }
}

Library: TokenHolderLib
Source: contracts/libraries/TokenHolderLib.sol
Address: N/A
Code:
//libraries/TokenHolderLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @title TokenHolderLib
/// @notice Utility library to manage tracking of token holders.
library TokenHolderLib {
    struct State {
        mapping(address => bool) isTokenHolder;
    }

    /// @notice Add an address to the tracked list if not already present.
    /// @param state Storage pointer to library state
    /// @param account Address to add
    function addTokenHolder(State storage state, address account) internal {
        if (!state.isTokenHolder[account]) {
            state.isTokenHolder[account] = true;
        }
    }

    /// @notice Mark an address as no longer holding tokens.
    /// @param state Storage pointer to library state
    /// @param account Address to remove
    function removeTokenHolder(State storage state, address account) internal {
        if (state.isTokenHolder[account]) {
            state.isTokenHolder[account] = false;
        }
    }
}

Library: VotingLib
Source: contracts/libraries/VotingLib.sol
Address: N/A
Code:
//libraries/VotingLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
import "./Errors.sol";

library VotingLib {
    function castVote(
        mapping(address => uint256) storage tokenUnlockTime,
        mapping(address => uint256) storage recentVoteTimestamps,
        function(address) view returns (uint256) getVotesFunc,
        uint256 tokenLockDuration,
        address voter
    ) internal {
        if (tokenUnlockTime[voter] > block.timestamp) revert Errors.TokensAlreadyLocked();
        if (getVotesFunc(voter) == 0) revert Errors.NoVotingPower();
        tokenUnlockTime[voter] = block.timestamp + tokenLockDuration;
        recentVoteTimestamps[voter] = block.timestamp;
    }

    /**
     * @notice Convert a voter's snapshot voting power into a USDT (6d) vote value.
     * @dev Uses getPastVotes at block.number - 1 to snapshot at the voting block and
     *      caps the result at 10% of the fundingAmount.
     * @param getPastVotesFunc Function to read past votes (ERC20Votes interface).
     * @param price Latest oracle price with 18 decimals.
     * @param voter Address whose voting power is evaluated.
     * @param fundingAmount Soft cap amount of the funding request in USDT (6d).
     * @return value The clamped voting value in USDT (6d).
     */
    function getVotingValueByVotes(
        function(address, uint256) view returns (uint256) getPastVotesFunc,
        int price,
        address voter,
        uint256 fundingAmount
    ) internal view returns (uint256 value) {
        uint256 vp = getPastVotesFunc(voter, block.number - 1);
        uint256 invValueUsd = (vp * uint256(price)) / 1e30; // USD(6)
        value = (invValueUsd * 5) / 1000; // 0.5% of holdings (USD6)
        uint256 maxValue = fundingAmount / 10; // 10% cap of request.amount (USD6)
        if (value > maxValue) value = maxValue;
    }

    function findLowestActiveEndorser(
        address[] storage activeList,
        function(address) view returns (uint256) getVotesFunc
    ) internal view returns (address lowest) {
        if (activeList.length == 0) {
            return address(0);
        }
        lowest = activeList[0];
        uint256 lowestVotes = getVotesFunc(lowest);
        for (uint256 i = 1; i < activeList.length; i++) {
            address current = activeList[i];
            uint256 votes = getVotesFunc(current);
            if (votes < lowestVotes) {
                lowestVotes = votes;
                lowest = current;
            }
        }
    }

    function prepareDelegatedVote(
        mapping(address => address) storage delegateMap,
        mapping(address => uint256) storage tokenUnlockTime,
        mapping(address => uint256) storage recentVoteTimestamps,
        function(address) view returns (uint256) getVotesFunc,
        uint256 tokenLockDuration,
        address sender,
        address tokenHolder
    ) internal returns (address voter, uint256 power) {
        voter = tokenHolder;
        if (voter == address(0)) revert Errors.InvalidTokenHolder();
        if (voter != sender) {
            if (delegateMap[voter] != sender) revert Errors.NotAuthorizedDelegate();
        }
        castVote(
            tokenUnlockTime,
            recentVoteTimestamps,
            getVotesFunc,
            tokenLockDuration,
            voter
        );
        power = getVotesFunc(voter);
    }
}

Library: WhitelistLib
Source: contracts/libraries/WhitelistLib.sol
Address: N/A
Code:
//libraries/WhitelistLib.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./EndorserLib.sol";

library WhitelistLib {
    enum RequestStatus { Pending, Approved, Rejected }

    struct Request {
        address applicant;
        EndorserLib.PersonalInfo info;
        RequestStatus status;
    }

    function removePending(uint256[] storage arr, uint256 id) internal {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] == id) {
                arr[i] = arr[arr.length - 1];
                arr.pop();
                break;
            }
        }
    }
}
